---
title: "小規模チームがゼロからTerraform構成を設計した話 - AI時代の運用を見据えて"
emoji: "🏗️"
type: "tech"
topics:
  - "terraform"
  - "gcp"
  - "devops"
  - "zennfes2025ai"
  - "zennfes2025infra"
published: true
publication_name: "pivotmedia"
---

こんにちは。PIVOTでソフトウェアエンジニアとして、Webフロントエンド、バックエンド、インフラを横断的に担当している[@tawachan](https://x.com/tawachan39)です。

この記事では、PIVOTのプロダクトチームでインフラのTerraform化を推進した経験を共有します。IaCできていなかった状態から、AI時代の運用を見据えた構成へと再設計した過程と判断基準について、振り返りながら紹介していきます。

## PIVOTのチーム状況と背景

### チーム体制

PIVOTはビジネス映像メディア「[PIVOT](https://pivotmedia.co.jp/)」を運営する会社です。開発チームは正社員エンジニア3名、QAエンジニア1名、プロダクトマネージャー1名、業務委託で数名という体制で、PIVOTというプロダクトの開発と社内システムのメンテナンスを主なスコープとしています。

エンジニア3名は、iOS、Android、Web（フロントエンド・バックエンド）をそれぞれ担当しており、私がWebを担当しつつインフラ周りも見ています。

### IaCできていなかった過去

もともとIaC化されていない状態でした：

- Google Cloudコンソール上からの手修正が常態化
- インフラ構成がコード化されておらず、属人化
- 変更履歴も追えない状態
- コンソールでぽちぽち操作していると意図しない変更をして事故ることもたまにあり、かなり不健全

よくある話ですが、これではインフラ変更のたびにコンソールを開き、手作業で設定を変更する運用が続きます。

### クラウドネイティブ化とIaC再構築の決断

内製化が進む中で、アーキテクチャをクラウドネイティブに寄せる作業が進行していました[^cloudnative]。このタイミングで、改めてIaC化を推進することを決めました。

ゼロからの構築なので、**現在のチーム状況に最適化した構成を新規設計**することにしました。そしてこの機会に、**AI時代の運用も考慮した設計**を取り入れることにしました。

[^cloudnative]: オンプレ時代にはローカルファイルにキャッシュを置くなどStatefulな構成で、そのままGoogle Cloud上のVMに移行していました。サーバーをGoで書き直しながら、ステートレスな構成にしてCloud Runに載せるアーキテクチャ刷新を進めていました。このあたりの話も別途記事にするかもしれません。

## Terraform構成のゼロからの設計

### 選択1: モノレポ vs リポジトリ分散管理

#### 分散管理での失敗経験

実は、モノレポ化する前にPoC的に各リポジトリでTerraformを管理してみたことがあります。サーバーやWebフロントエンドのリポジトリそれぞれにCloud RunなどのTerraformコードを配置してみたのですが、早々に問題が見えてきました：

- ほぼ同じリソース（Cloud Run）なのに、リポジトリごとにフォルダ構成が微妙に違う
- 命名規則や変数の定義方法も統一されていない
- どうせ自分が全て操作するのに、リポジトリによって書き方が違うのがやりづらい
- すでに管理が煩雑になりそうで、破綻の予感がした

この経験から、「分散的にやりたくない」という気持ちが強くなり、モノレポ化を真剣に検討し始めました。

#### 我々の選択: モノレポで一元管理

理由:

1. **チーム体制**: チームは1つ、インフラを見るのも固定メンバー
2. **実体験からの学び**: 分散管理は小規模チームではすぐに破綻する
3. **スケール後の懸念が少ない**: LayerXのようにスケールしているチームでもモノレポを採用している[^layerx]なら、将来的にチームが成長しても大きな問題はないだろう

[^layerx]: [Terraform運用のベストプラクティス - LayerX Tech Blog](https://tech.layerx.co.jp/entry/2025/03/24/113651)

### 選択2: リソース種別ベースの構成

#### PIVOTの状況

PIVOTは1つのプロダクトを1つのチームで開発しており、複数プロダクトを複数チームで開発しているわけではありません。サーバー、フロントエンド、バッチなど、デプロイ単位や開発担当の違いはありますが、これらは「プロダクト」というより「コンポーネント」の分類に近いものです。

チームトポロジーの観点では、複数のプロダクトチームがそれぞれのインフラを管理する構成が理想的なケースもあります。しかし、我々は1チームで全体を見ているため、そのような組織的な境界はありません。

#### 我々の選択: リソース種別ベースで横並び管理

この状況を踏まえ、以下の構成を採用しました：

```
modules/google-cloud/       # リソース種別ごとのモジュール
  ├── cloud-run-api/
  ├── cloud-run-web/
  └── cloud-run-job/

platform/google-cloud/      # 環境ごとの実装
  ├── pivot-stg/
  │   ├── cloud-run/       # 全てのCloud Runサービス
  │   ├── cloud-run-jobs/  # 全てのバッチジョブ
  │   └── ...
  └── pivot-prod/
      └── ...
```

この構成のメリット:

1. **横並びでの比較が容易**: 同じリソース種別（例: Cloud Run）の設定が一箇所に集まっているため、設定の統一や比較が簡単
2. **固定担当者の見通しの良さ**: 担当が固定されている場合、リソース種別で整理されている方が認知負荷が低い

もし複数プロダクトを複数チームで開発する状況になれば、プロダクトチームごとの管理を検討することになるでしょう。しかし現時点では、リソース種別ベースで横並び管理することが、最も見通しがよく効率的だと判断しました。

## AI時代を見据えた設計判断

上記の選択において、実は**AI活用**という観点が重要な判断軸になっていました。

### モノレポがAI活用に有利な理由

コンテキストが一箇所に集約されることで、Claude CodeやCodex CLIが全体を理解しやすくなります。実際に分散管理を試してみて、同じリソース種別が複数箇所に散らばることの煩雑さを体感したことが、モノレポ化の強い動機になりました。

AIツールは関連するコードが近くにあることで、より適切な提案ができます。リソースが点在していると、AIは「どのリポジトリのどのファイルか」を探すところから始める必要があります。

### リソース種別ベースがAI活用に有利な理由

同じリソース種別が横並びで存在することで、AIが既存設定を参考にしやすくなります。具体的には：

- **「既存のバッチジョブと同じ構成で新しいデータ処理ジョブを作って」**: 同じ `cloud-run-jobs/` ディレクトリ内の設定を参照して適切に生成
- **「全てのCloud Runサービスのタイムアウトを60秒に統一して」**: `cloud-run/` ディレクトリ全体を一度に処理できる
- **「このAPIサーバーのCloud Monitoringアラートで、エラー率5%以上で通知して」**: `monitoring/` と `cloud-run/` を横断的に参照して設定

また、変数名や命名規則が統一されているため、AIが既存パターンを学習しやすく、一貫性のある変更提案が得られます。

### AI時代のインフラ運用

従来は「Terraformの書き方」を覚える必要がありましたが、AI時代では「何をしたいか」を自然言語で伝えれば、AIが適切なTerraformコードに変換してくれます。

この時、**参考にできるコードが近くにあること**が重要になります。モノレポかつリソース種別ベースの構成は、この要件を満たす理想的な形です。

## GitOpsフローの実現

### なぜGitOpsフローが必要だったか

最初はローカルでTerraform applyしていました。しかし、それでは以下の問題がありました：

- インフラ変更の履歴が残らない
- レビューなしで変更できてしまう
- 誰がいつ何を変更したのかわからない

**必ずPRでApproveを貰わないと変更できない**という統制を実現するため、GitOpsフローの構築を決めました。

### 基本的な仕組み

**GitHub Actions + Workload Identity Federation**でCI/CDを構築しています：

- **PR時**: 変更されたTerraformコードに対して自動でplanを実行し、結果をPRコメントに投稿
- **マージ時**: mainブランチへのマージで自動apply
- **認証**: Workload Identity Federationにより、サービスアカウントキー不要で安全に認証
- **権限分離**: planとapplyで異なるサービスアカウントを使用

### 複数のtfstateへの対応

tfstateはリソース種別ごとに分割し、GCS bucketで管理しています：

```hcl
# platform/pivot-prod/cloud-run/backend.tf
terraform {
  backend "gcs" {
    bucket = "pivot-terraform-state"
    prefix = "prod/cloud-run"
  }
}
```

分割する理由:

- **stateの肥大化を避ける**: 1つのstateに全リソースを入れると管理が煩雑になる
- **影響範囲を限定**: 誤った変更があっても、該当するリソース種別のみに影響を限定できる
- **並行作業の容易性**: 異なるリソース種別なら同時に作業できる

変更されたディレクトリを検出し、該当するstackに対してのみplan/applyを実行する仕組みを構築しています。また、`modules/` 配下が変更された場合は、そのmoduleを利用している全てのstackに対してplanを実行します。

複数のリソース種別を同時に変更した場合、それぞれのstackに対して並列にplan/applyが実行され、各stackごとにPRコメントが投稿されます。

![複数stackの並列実行](/images/terraform-multiple-stacks-parallel.png)

この仕組みの詳細については、別途記事にする予定です。

### Plan結果の可視化

Terraform plan結果がPRコメントに自動投稿され、変更内容が可視化されます。mainブランチへのマージで自動applyが実行され、完了すると元のPRコメントに結果が追記されます。

![PRコメントでのTerraform Plan/Apply結果](/images/terraform-plan-apply-pr-comment.png)

この仕組みにより、エンジニアなら誰でも以下のフローでインフラ変更ができます：

1. ブランチを切ってTerraformコードを変更
2. PRを作成すると、自動でplan結果がコメントされる
3. レビュアーが影響範囲を確認
4. マージすると自動で本番環境に適用

Google Cloudコンソールを直接触る必要はありません（むしろ禁止しています）。

## 参考にした知見と独自の解釈

Terraform構成を検討する中で、前述のLayerXの記事に出会いました。

### LayerX記事からの学び

**中央管理の合理性**: LayerXは、メンバーが多く、プロダクト側にインフラ責務を渡してもよさそうな規模でも、メンテコスト観点で中央管理を選択していました。

**我々の解釈**: 大規模チームでさえ中央管理なら、小規模チームの我々はより一層、集約管理が合理的です。

**将来の拡張を見越した設計**: GitHub組織管理、マルチクラウド等も視野に入れたディレクトリ構成を参考にしました。我々も同様のアプローチで、将来的にGitHub組織・チーム・リポジトリ管理(`modules/github/`)なども追加できる箱を作っています。

### 状況依存の意思決定

Terraform構成に「絶対的な正解」は存在しません。チーム規模、成長フェーズ、インフラ担当の体制、プロダクトの独立性など、様々な要素で最適解は変わります。

我々の判断軸（2025年時点）：

1. **小規模チームのフットワークの軽さを活かす**: 固定メンバーで見通しよく管理、素早い意思決定と変更
2. **AI時代のコード構成への配慮**: コンテキスト集約によるAI活用の最大化、自然言語でのインフラ操作を前提とした設計
3. **将来の拡張性**: GitHub管理のIaC化、他サービス・他クラウドの追加も見据えた箱作り

この構成がフィットしなくなるタイミング（プロダクトチームが複数に増える、インフラ担当が複数になる、プロダクトごとのデプロイサイクルが完全に独立する）では、改めて再検討すればよいと考えています。

## 現在の到達点

### 実現できたこと

- プロダクト開発に関わる主要リソースのTerraform化完了
- GitOpsフローの確立（PR→plan、merge→apply）
- 誰でも安全にインフラ変更できる環境
- **AI支援によるインフラ操作の民主化**

特に最後の点は重要です。Terraformの書き方を知らないメンバーでも、AIに自然言語で指示することで、インフラ変更を提案できるようになりました。

### 今後の課題

現在はプロダクト開発に関わる主要リソースのTerraform化を完了していますが、まだ残っているリソースがあります。次のステップは以下です：

- **ネットワーク周りなど基盤的なリソースのTerraform化**: VPCやサブネットなど、まだコンソールで管理しているリソースを順次Terraform化
- **GitHub組織管理のIaC化**: チーム・リポジトリ管理もコード化し、全てのインフラをIaCで管理する状態を目指す

## おわりに

振り返ると、Terraform構成の再設計は、技術的な挑戦であると同時に、チームの状況を深く理解する機会でもありました。

今回の取り組みを通じて学んだことは、ベストプラクティスは参考にしつつも、自分たちのチームの状況、成長フェーズ、文化に合わせて選択することの重要性です。そして、状況が変われば構成も変える柔軟性を持つことが大切だと感じています。

特に印象的だったのは、**AI活用を前提にした設計の重要性**です。これからのインフラ運用では、AIがコードを読み書きすることが前提になります。コンテキストの集約、参照可能性、一貫性といった要素が、従来以上に重要になってきています。

この記事が、同じような状況にあるチームの参考になれば幸いです。もし質問やフィードバックがあれば、ぜひコメントやXでお気軽に声をかけてください。
